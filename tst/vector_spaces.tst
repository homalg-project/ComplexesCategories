# ComplexesForCAP, single 1
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#

gap> START_TEST( "complexesforcap01.tst");

# doc/_Chunks.xml:9-17
gap> Q := HomalgFieldOfRationals( );;
gap> matrix_category := MatrixCategory( Q );
Category of matrices over Q
gap> cochain_cat := CochainComplexCategory( matrix_category );
Cochain complexes category over Category of matrices over Q
gap> A := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> B := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> f := VectorSpaceMorphism( A, HomalgMatrix( [ [ 1, 3 ] ], 1, 2, Q ), B );
<A morphism in Category of matrices over Q>
gap> g := VectorSpaceMorphism( B, HomalgMatrix( [ [ 0 ], [ 0 ] ], 2, 1, Q ), A );
<A morphism in Category of matrices over Q>
gap> C := CochainComplex( [ f, g, 2*f ], 3 );
<A bounded object in Cochain complexes category over Category of matrices over Q 
with active lower bound 2 and active upper bound 7>
gap> ActiveUpperBound( C );
7
gap> ActiveLowerBound( C );
2
gap> C[ 1 ];
<A vector space object over Q of dimension 0>
gap> C[ 3 ];
<A vector space object over Q of dimension 1>
gap> C^3;
<A morphism in Category of matrices over Q>
gap> C^3 = f;
true
gap> Display( CyclesAt( C, 4 ) );
[ [  1,  0 ],
  [  0,  1 ] ]

A split monomorphism in Category of matrices over Q
gap> diffs := Differentials( C );
<An infinite list>
gap> diffs[ 1 ];
<A zero, isomorphism in Category of matrices over Q>
gap> diffs[ 10000 ];
<A zero, isomorphism in Category of matrices over Q>
gap> objs := Objects( C );
<An infinite list>
gap> DefectOfExactnessAt( C, 4 );
<A vector space object over Q of dimension 1>
gap> DefectOfExactnessAt( C, 3 );
<A vector space object over Q of dimension 0>
gap> IsExactInIndex( C, 4 );
false
gap> IsExactInIndex( C, 3 );
true
gap> C;
<A not cyclic, bounded object in Cochain complexes category over Category of 
matrices over Q with active lower bound 2 and active upper bound 7>
gap> P := CochainComplex( matrix_category, diffs );
<An object in Cochain complexes category over Category of matrices over Q>
gap> SetUpperBound( P, 15 );
gap> P;
<A bounded from above object in Cochain complexes category over Category of 
matrices over Q with active upper bound 15>
gap> SetUpperBound( P, 20 );
gap> P;
<A bounded from above object in Cochain complexes category over Category of 
matrices over Q with active upper bound 15>
gap> ActiveUpperBound( P );
15
gap> SetUpperBound( P, 7 );
gap> P;
<A bounded from above object in Cochain complexes category over Category of 
matrices over Q with active upper bound 7>
gap> ActiveUpperBound( P );
7
gap> h := VectorSpaceMorphism( A, HomalgMatrix( [ [ 5 ] ], 1, 1, Q ), A );
<A morphism in Category of matrices over Q>
gap> phi4 := g;
<A morphism in Category of matrices over Q>
gap> phi5 := 2*h;
<A morphism in Category of matrices over Q>
gap> D := CochainComplex( [ h ], 4 );
<A bounded object in Cochain complexes category over Category of matrices 
over Q with active lower bound 3 and active upper bound 6>
gap> phi := CochainMorphism( C, D, [ phi4, phi5 ], 4 );
<A bounded morphism in Cochain complexes category over Category of matrices
 over Q with active lower bound 3 and active upper bound 6>
gap> Display( phi[ 5 ] );
[ [ 10 ] ]

A morphism in Category of matrices over Q
gap> ActiveLowerBound( phi );
3
gap> IsZeroForMorphisms( phi );
false
gap> IsExact( D );
true
gap> IsExact( C );
false
gap> psi := CochainMorphism( [ f, g, 2*f ], 3, [ h ], 4, [ phi4, phi5 ], 4 );
<A bounded morphism in Cochain complexes category over Category of matrices 
over Q with active lower bound 3 and active upper bound 6>
gap> IsZeroForMorphisms( psi );
false
gap> psi;
<A bounded morphism in Cochain complexes category over Category of matrices 
over Q with active lower bound 4 and active upper bound 6>
gap> cone := MappingCone( psi );
<A bounded object in Cochain complexes category over Category of matrices over 
Q with active lower bound 1 and active upper bound 6>
gap> cone^4;
<A morphism in Category of matrices over Q>
gap> Display( cone^4 );
[ [   -2,   -6,  10 ],
  [    0,    0,    5 ] ]

A morphism in Category of matrices over Q
gap> i := NaturalInjectionInMappingCone( psi );
<A bounded morphism in Cochain complexes category over Category of matrices over
Q with active lower bound 3 and active upper bound 6>
gap> p := NaturalProjectionFromMappingCone( psi );
<A bounded morphism in Cochain complexes category over Category of matrices over
Q with active lower bound 1 and active upper bound 6>
gap> IsZeroForMorphisms( PreCompose( psi, i ) );
false
gap> IsNullHomotopic( PreCompose( psi, i ) );
true
gap> H := HomotopyMorphisms( PreCompose( psi, i ) );
<An infinite list>
gap> Display( H[ 5 ] );
[ [  0,  2 ] ]

A morphism in Category of matrices over Q
gap> Display( H[ 4 ] );
[ [  0,  0 ],
  [  0,  0 ] ]

A morphism in Category of matrices over Q
gap> Display( H[ 3 ] );
[ [  0 ] ]

A morphism in Category of matrices over Q
gap> cyl_psi := MappingCylinder( psi );
<A bounded object in Cochain complexes category over Category of matrices over Q
with active lower bound 1 and active upper bound 7>
gap> D_to_cyl_psi := NaturalInjectionOfRangeInMappingCylinder( psi );
<A bounded morphism in Cochain complexes category over Category of matrices over
Q with active lower bound 3 and active upper bound 6>
gap> cyl_psi_to_D := NaturalMorphismFromMappingCylinderInRange( psi );
<A bounded morphism in Cochain complexes category over Category of matrices over
Q with active lower bound 3 and active upper bound 6>
gap> IsZeroForMorphisms( PreCompose( D_to_cyl_psi, cyl_psi_to_D ) 
>                     - IdentityMorphism( D ) );
true
gap> IsZeroForMorphisms( PreCompose( cyl_psi_to_D, D_to_cyl_psi ) 
>                     - IdentityMorphism( cyl_psi ) );
false
gap> IsNullHomotopic( PreCompose( cyl_psi_to_D, D_to_cyl_psi ) 
>                     - IdentityMorphism( cyl_psi ) );
true
gap> # Display( D_to_cyl_psi );
gap> # Display( cyl_psi_to_D );
gap> i_o_psi := PreCompose( psi, i );
<A bounded morphism in Cochain complexes category over Category of matrices
over Q with active lower bound 4 and active upper bound 6>
gap> H5 := CohomologyFunctorAt( cochain_cat, matrix_category, 5 );
5-th cohomology functor in Category of matrices over Q
gap> IsZeroForMorphisms( ApplyFunctor( H5, i_o_psi ) );
true
gap> F := CapFunctor( "double functor", matrix_category, matrix_category );
double functor
gap> u := function( obj ) return DirectSum( [ obj, obj ] ); end;;
gap> AddObjectFunction( F, u );
gap> v := function( s, mor, r ) return DirectSumFunctorial( [ mor, mor ] ); end;;
gap> AddMorphismFunction( F, v );
gap> Display( f );
[ [  1,  3 ] ]

A split monomorphism in Category of matrices over Q
gap> Display( ApplyFunctor( F, f ) );
[ [  1,  3,  0,  0 ],
  [  0,  0,  1,  3 ] ]

A morphism in Category of matrices over Q
gap> Coch_F := ExtendFunctorToCochainComplexCategoryFunctor( F );;
gap> psi;
<A bounded morphism in Cochain complexes category over Category of matrices 
over Q with active lower bound 4 and active upper bound 6>
gap> Coch_F_psi := ApplyFunctor( Coch_F, psi );
<A bounded morphism in Cochain complexes category over Category of matrices 
over Q with active lower bound 4 and active upper bound 6>
gap> Display( psi[ 5 ] );
[ [  10 ] ]

A morphism in Category of matrices over Q
gap> Display( Coch_F_psi[ 5 ] );
[ [  10,   0 ],
  [   0,  10 ] ]

A morphism in Category of matrices over Q
gap> T := ShiftFunctor( cochain_cat, 3 );
Shift (3 times to the left) functor in Cochain complexes category over Category
 of matrices over Q
gap> C;
<A not cyclic, bounded object in Cochain complexes category over Category of 
matrices over Q with active lower bound 2 and active upper bound 7>
gap> C_3 := ApplyFunctor( T, C );
<A not cyclic, bounded object in Cochain complexes category over Category of 
matrices over Q with active lower bound -1 and active upper bound 4>
gap> Display( C^3 );
[ [  1,  3 ] ]

A split monomorphism in Category of matrices over Q
gap> Display( C_3^0 );
[ [  -1,  -3 ] ]

A morphism in Category of matrices over Q
gap> S := UnsignedShiftFunctor( cochain_cat, 3 );
Unsigned shift (3 times to the left) functor in Cochain complexes category over 
Category of matrices over Q
gap> C_3_unsigned := ApplyFunctor( S, C );
<A bounded object in Cochain complexes category over Category of matrices over 
Q with active lower bound -1 and active upper bound 4>
gap> Display( C_3_unsigned^0 );
[ [  1,  3 ] ]

A split monomorphism in Category of matrices over Q
gap> cochain_cat;
Cochain complexes category over Category of matrices over Q
gap> chain_cat := ChainComplexCategory( matrix_category );
Chain complexes category over Category of matrices over Q
gap> trunc_leq_4 := BrutalTruncationAboveFunctor( cochain_cat, 4 );
Functor of brutal truncation from above (C -> C^<= 4) in Cochain complexes 
category over Category of matrices over Q
gap> trunc_l_4 := BrutalTruncationAboveFunctor( chain_cat, 4 );
Functor of brutal truncation from above (C -> C_< 4) in Chain complexes 
category over Category of matrices over Q
gap> trunc_g_4 := BrutalTruncationBelowFunctor( cochain_cat, 4 );
Functor of brutal truncation from below (C -> C^> 4) in Cochain complexes 
category over Category of matrices over Q
gap> trunc_geq_4 := BrutalTruncationBelowFunctor( chain_cat, 4 );
Functor of brutal truncation from below (C -> C_>= 4) in Chain complexes 
category over Category of matrices over Q
gap> ApplyFunctor( trunc_leq_4, C );
<A bounded object in Cochain complexes category over Category of matrices over Q \
with active lower bound 2 and active upper bound 5>
gap> ApplyFunctor( trunc_g_4, C );
<A bounded object in Cochain complexes category over Category of matrices over Q \
with active lower bound 4 and active upper bound 7>
