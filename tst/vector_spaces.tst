# ComplexesForCAP, single 1
#
# DO NOT EDIT THIS FILE - EDIT EXAMPLES IN THE SOURCE INSTEAD!
#
# This file has been generated by AutoDoc. It contains examples extracted from
# the package documentation. Each example is preceded by a comment which gives
# the name of a GAPDoc XML file and a line range from which the example were
# taken. Note that the XML file in turn may have been generated by AutoDoc
# from some other input.
#

gap> START_TEST( "complexesforcap01.tst");

# doc/_Chunks.xml:9-17
gap> Q := HomalgFieldOfRationals( );;
gap> matrix_category := MatrixCategory( Q );
Category of matrices over Q
gap> cochain_cat := CochainComplexCategory( matrix_category );;
gap> A := VectorSpaceObject( 1, Q );
<A vector space object over Q of dimension 1>
gap> B := VectorSpaceObject( 2, Q );
<A vector space object over Q of dimension 2>
gap> f := VectorSpaceMorphism( A, HomalgMatrix( [ [ 1, 3 ] ], 1, 2, Q ), B );
<A morphism in Category of matrices over Q>
gap> g := VectorSpaceMorphism( B, HomalgMatrix( [ [ 0 ], [ 0 ] ], 2, 1, Q ), A );
<A morphism in Category of matrices over Q>
gap> C := CochainComplex( [ f, g, 2*f ], 3 );;
gap> ActiveUpperBound( C );
6
gap> ActiveLowerBound( C );
3
gap> C[ 1 ];
<A vector space object over Q of dimension 0>
gap> C[ 3 ];
<A vector space object over Q of dimension 1>
gap> C^3;
<A morphism in Category of matrices over Q>
gap> C^3 = f;
true
gap> Display( CyclesAt( C, 4 ) );
[ [  1,  0 ],
  [  0,  1 ] ]

A split monomorphism in Category of matrices over Q
gap> diffs := Differentials( C );;
gap> diffs[ 1 ];
<A zero, isomorphism in Category of matrices over Q>
gap> diffs[ 10000 ];
<A zero, isomorphism in Category of matrices over Q>
gap> objs := Objects( C );;
gap> DefectOfExactnessAt( C, 4 );
<A vector space object over Q of dimension 1>
gap> DefectOfExactnessAt( C, 3 );
<A vector space object over Q of dimension 0>
gap> IsExactInIndex( C, 4 );
false
gap> IsExactInIndex( C, 3 );
true
gap> C;;
gap> P := CochainComplex( matrix_category, diffs );;
gap> SetUpperBound( P, 15 );;
gap> P;;
gap> SetUpperBound( P, 20 );;
gap> P;;
gap> ActiveUpperBound( P );
15
gap> SetUpperBound( P, 7 );
gap> P;;
gap> ActiveUpperBound( P );
7
gap> h := VectorSpaceMorphism( A, HomalgMatrix( [ [ 5 ] ], 1, 1, Q ), A );
<A morphism in Category of matrices over Q>
gap> phi4 := g;
<A morphism in Category of matrices over Q>
gap> phi5 := 2*h;
<A morphism in Category of matrices over Q>
gap> D := CochainComplex( [ h ], 4 );;
gap> phi := CochainMorphism( C, D, [ phi4, phi5 ], 4 );;
gap> Display( phi[ 5 ] );
[ [ 10 ] ]

A morphism in Category of matrices over Q
gap> ActiveLowerBound( phi );
4
gap> IsZeroForMorphisms( phi );
false
gap> IsExact( D );
true
gap> IsExact( C );
false
gap> psi := CochainMorphism( [ f, g, 2*f ], 3, [ h ], 4, [ phi4, phi5 ], 4 );;
gap> IsZeroForMorphisms( psi );
false
gap> psi;;
gap> cone := MappingCone( psi );;
gap> cone^4;
<A morphism in Category of matrices over Q>
gap> Display( cone^4 );
[ [   -2,   -6,  10 ],
  [    0,    0,    5 ] ]

A morphism in Category of matrices over Q
gap> i := NaturalInjectionInMappingCone( psi );;
gap> p := NaturalProjectionFromMappingCone( psi );;
gap> IsZeroForMorphisms( PreCompose( psi, i ) );
false
gap> IsNullHomotopic( PreCompose( psi, i ) );
true
gap> H := HomotopyMorphisms( PreCompose( psi, i ) );;
gap> Display( H[ 5 ] );
[ [  0,  2 ] ]

A morphism in Category of matrices over Q
gap> Display( H[ 4 ] );
[ [  0,  0 ],
  [  0,  0 ] ]

A morphism in Category of matrices over Q
gap> Display( H[ 3 ] );
[ [  0 ] ]

A morphism in Category of matrices over Q
gap> cyl_psi := MappingCylinder( psi );;
gap> D_to_cyl_psi := NaturalInjectionOfRangeInMappingCylinder( psi );;
gap> cyl_psi_to_D := NaturalMorphismFromMappingCylinderInRange( psi );;
gap> IsZeroForMorphisms( PreCompose( D_to_cyl_psi, cyl_psi_to_D ) 
>                     - IdentityMorphism( D ) );
true
gap> IsZeroForMorphisms( PreCompose( cyl_psi_to_D, D_to_cyl_psi ) 
>                     - IdentityMorphism( cyl_psi ) );
false
gap> IsNullHomotopic( PreCompose( cyl_psi_to_D, D_to_cyl_psi ) 
>                     - IdentityMorphism( cyl_psi ) );
true
gap> # Display( D_to_cyl_psi );
gap> # Display( cyl_psi_to_D );
gap> i_o_psi := PreCompose( psi, i );;
gap> H5 := CohomologyFunctor( cochain_cat, 5 );
5-th cohomology functor in Category of matrices over Q
gap> IsZeroForMorphisms( ApplyFunctor( H5, i_o_psi ) );
true
gap> F := CapFunctor( "double functor", matrix_category, matrix_category );
double functor
gap> u := function( obj ) return DirectSum( [ obj, obj ] ); end;;
gap> AddObjectFunction( F, u );
gap> v := function( s, mor, r ) return DirectSumFunctorial( [ mor, mor ] ); end;;
gap> AddMorphismFunction( F, v );
gap> Display( f );
[ [  1,  3 ] ]

A split monomorphism in Category of matrices over Q
gap> Display( ApplyFunctor( F, f ) );
[ [  1,  3,  0,  0 ],
  [  0,  0,  1,  3 ] ]

A morphism in Category of matrices over Q
gap> Coch_F := ExtendFunctorToCochainComplexCategories( F );;
gap> psi;;
gap> Coch_F_psi := ApplyFunctor( Coch_F, psi );;
gap> Display( psi[ 5 ] );
[ [  10 ] ]

A morphism in Category of matrices over Q
gap> Display( Coch_F_psi[ 5 ] );
[ [  10,   0 ],
  [   0,  10 ] ]

A morphism in Category of matrices over Q
gap> T := ShiftFunctor( cochain_cat, 3 );;
gap> C;;
gap> C_3 := ApplyFunctor( T, C );;
gap> Display( C^3 );
[ [  1,  3 ] ]

A split monomorphism in Category of matrices over Q
gap> Display( C_3^0 );
[ [  -1,  -3 ] ]

A morphism in Category of matrices over Q
gap> S := UnsignedShiftFunctor( cochain_cat, 3 );;
gap> C_3_unsigned := ApplyFunctor( S, C );;
gap> Display( C_3_unsigned^0 );
[ [  1,  3 ] ]

A split monomorphism in Category of matrices over Q

